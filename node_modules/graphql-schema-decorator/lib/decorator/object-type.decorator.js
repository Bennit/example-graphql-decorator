"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const type_factory_1 = require("../type-factory");
const metadata_builder_1 = require("../metadata-builder");
/**
 * It is used to create {@link GraphQLObjectType} objects.
 * See [GraphQL Documentation - Object Types]{@http://graphql.org/learn/schema/#object-types-and-fields}
 *
 * @param option Options for an Object Type
 */
function ObjectType(option) {
    return CreateObjectType(false, option);
}
exports.ObjectType = ObjectType;
/**
 * It is used to create {@link GraphQLInputObjectType} objects.
 * See [GraphQL Documentation - Input Types]{@http://graphql.org/learn/schema/#input-types}
 *
 * @param option Options for an Input Object Type
 */
function InputObjectType(option) {
    return CreateObjectType(true, option);
}
exports.InputObjectType = InputObjectType;
function CreateObjectType(isInput, option) {
    return function (target) {
        if (isInput && option && option.interfaces) {
            throw new type_factory_1.SchemaFactoryError(`Input types are not allowed to have interfaces: '${target.name}'`, type_factory_1.SchemaFactoryErrorType.INPUT_FIELD_SHOULD_NOT_HAVE_INTERFACE);
        }
        metadata_builder_1.getMetadataArgsStorage().objects.push({
            target: target,
            name: target.name,
            description: option ? option.description : null,
            isInput: isInput,
            interfaces: option && option.interfaces ? (option.interfaces.constructor !== Array ? [option.interfaces] : option.interfaces) : [],
        });
    };
}
//# sourceMappingURL=object-type.decorator.js.map