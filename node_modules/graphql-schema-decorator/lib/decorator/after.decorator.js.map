{"version":3,"file":"after.decorator.js","sourceRoot":"","sources":["../../src/decorator/after.decorator.ts"],"names":[],"mappings":";;AAEA,0DAA6D;AAE7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCG;AACH,eAAsB,MAAqC;IACzD,MAAM,CAAC,UAAU,MAAW,EAAE,WAAgB,EAAE,KAAa;QAC3D,yCAAsB,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC;YACnC,MAAM,EAAE,MAAM;YACd,IAAI,EAAE,MAAM,CAAC,IAAI,IAAI,WAAW;YAChC,WAAW,EAAE,MAAM,IAAK,MAAsB,CAAC,WAAW,GAAI,MAAsB,CAAC,WAAW,GAAG,IAAI;YACvG,KAAK,EAAE,KAAK;YACZ,QAAQ,EAAE,WAAW;YACrB,UAAU,EAAE,MAAM,IAAK,MAAsB,CAAC,UAAU,GAAI,MAAsB,CAAC,UAAU,GAAG,MAAyB;SAC1H,CAAC,CAAC;IACL,CAAa,CAAC;AAChB,CAAC;AAXD,sBAWC","sourcesContent":["import { AfterMiddleware } from '../middleware';\nimport { AfterOption } from '../metadata';\nimport { getMetadataArgsStorage } from '../metadata-builder';\n\n/**\n * Adding ability to declarative override function resolution on schemas with an implementation analog to an express middleware.\n *\n * Usage example:\n * ```\n * let middleware: AfterMiddleware = (\n *   context: any,\n *   args: { [key: string]: any },\n *   result: Promise<any> | any,\n *   next: (error?: Error, value?: any) => any\n * ): any => {\n *   if(context.user.role != 'any role') {\n *     // can use context and resolve/return value as `1000`, for example, regardless of what resolve function actually implements\n *     next(null, 1000);\n *   } else {\n *     // keeps regular resolution flow\n *     next();\n *   }\n * };\n *\n * ...\n *\n * class ObjType {\n *   @Field()\n *   @After(middleware)\n *   myFunction(input: number): number {\n *     return input * 2;\n *   }\n * }\n *\n * ```\n * @param option Options for an Schema\n */\nexport function After(option: AfterOption | AfterMiddleware) {\n  return function (target: any, propertyKey: any, index: number) {\n    getMetadataArgsStorage().afters.push({\n      target: target,\n      name: target.name || propertyKey,\n      description: option && (option as AfterOption).description ? (option as AfterOption).description : null,\n      index: index,\n      property: propertyKey,\n      middleware: option && (option as AfterOption).middleware ? (option as AfterOption).middleware : option as AfterMiddleware,\n    });\n  } as Function;\n}\n"]}