{"version":3,"file":"field.type-factory.js","sourceRoot":"","sources":["../../src/type-factory/field.type-factory.ts"],"names":[],"mappings":";;AAAA,mCAAmC;AAOnC,+DAAmF;AAEnF,oDAAgD;AAChD,mEAA6D;AAC7D,wDAAoD;AACpD,2DAAsD;AACtD,0DAA6D;AAC7D,qEAAgE;AAChE,+DAA0D;AAC1D,6DAAwD;AAOxD,IAAI,cAAc,GAA2B,EAAE,CAAC;AAEhD;IACE,2CAA2C;IAC3C,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;SACxB,OAAO,CAAC,GAAG,IAAI,OAAO,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC;AAChD,CAAC;AAJD,kDAIC;AAED,qBAAqB,MAAgB,EAAE,QAA0C,EAAE,OAAgB;IACjG,IAAI,UAAe,CAAC;IAEpB,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;QACnB,EAAE,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC;YACtB,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,CAAK,kBAAkB;QACzD,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC;YAC7B,UAAU,GAAG,OAAO,CAAC,aAAa,CAAC;QACrC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,KAAK,OAAO,CAAC,CAAC,CAAC;YAC9B,UAAU,GAAG,OAAO,CAAC,cAAc,CAAC;QACtC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,SAAS,IAAI,yCAAsB,EAAE,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC7G,iCAAiC;YACjC,UAAU,GAAG,uCAAiB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAClD,CAAC;IACH,CAAC;IAAC,IAAI,CAAC,CAAC;QACN,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC;QAE3B,EAAE,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,SAAS,IAAI,yCAAsB,EAAE,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACjH,UAAU,GAAG,qCAAgB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QACrD,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,SAAS,IAAI,yCAAsB,EAAE,CAAC,uBAAuB,CAAC,UAAU,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACzH,iCAAiC;YACjC,UAAU,GAAG,uCAAiB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QACtD,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,SAAS,IAAI,yCAAsB,EAAE,CAAC,0BAA0B,CAAC,UAAU,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC5H,UAAU,GAAG,6CAAoB,CAAC,UAAU,CAAC,CAAC;QAChD,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,SAAS,IAAI,yCAAsB,EAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACpH,UAAU,GAAG,mCAAe,CAAC,UAAU,CAAC,CAAC;QAC3C,CAAC;IACH,CAAC;IAED,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC;QAAC,MAAM,CAAC,IAAI,CAAC;IAE7B,wCAAwC;IACxC,6FAA6F;IAC7F,iFAAiF;IACjF,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACxD,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC;IAC/C,CAAC;IACD,UAAU,GAAG,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC;IAE3D,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;QACpB,UAAU,GAAG,IAAI,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;IACnD,CAAC;IACD,EAAE,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC;QACvB,UAAU,GAAG,IAAI,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;IACtD,CAAC;IACD,EAAE,CAAC,CAAE,QAAgB,CAAC,YAAY,CAAC,CAAC,CAAC;QACnC,UAAU,GAAG,gCAAc,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;IAC/D,CAAC;IAED,MAAM,CAAC,UAAU,CAAC;AAEpB,CAAC;AAED,yBACE,MAAgB,EAChB,QAAuB,EACvB,gBAAsB;IAEtB,MAAM,cAAc,GAAG,OAAO,CAAC,WAAW,CAAC,mBAAmB,EAAE,MAAM,CAAC,SAAS,EAAE,QAAQ,CAAC,IAAI,CAAe,CAAC;IAC/G,MAAM,iBAAiB,GAA6B,EAAE,CAAC;IACvD,MAAM,QAAQ,GAAgC,EAAE,CAAC;IAEjD,EAAE,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;QACrB,QAAQ,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC;IAC/C,CAAC;IACD,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;QAClB,QAAQ,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;IACzC,CAAC;IAED,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,IAAI,QAAQ,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;QAC9E,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,KAAK;YACpC,MAAM,gBAAgB,GAAG,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;iBACnE,MAAM,CAAC,KAAK,IAAI,KAAK,CAAC;iBACtB,IAAI,CAAC,CAAC,KAAyC,KAAK,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC,0DAA0D;YACzI,EAAE,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;gBACrB,iBAAiB,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG;oBACzC,IAAI,EAAE,gBAAgB,CAAC,IAAI;oBAC3B,IAAI,EAAE,WAAW,CAAC,OAAO,EAAE,gBAAgB,EAAE,IAAI,CAAC;iBACnD,CAAC;gBACF,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;YAC1C,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,MAAM,UAAU,GAAG,CAAC,gBAAgB,GAAG,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAa,GAAG,IAAI,CAAC,CAAC;IAC3F,MAAM,EAAE,GAAG,CAAC,gBAAgB,GAAG,IAAI,GAAG,UAAU,IAAS,EAAE,IAA8B,EAAE,OAAY,EAAE,IAAS;QAChH,MAAM,IAAI,GAAU,EAAE,CAAC;QACvB,qCAAqC;QACrC,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG;YACjC,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;YAC5B,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC;gBACf,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;YAC1B,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;YACrB,MAAM,KAAK,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;YAClC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC;gBACf,IAAI,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC;YACxB,CAAC;QACH,CAAC;QAED,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC/B,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC;gBACf,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;YACrB,CAAC;QACH,CAAC;QAED,IAAI,MAAM,GAAQ,IAAI,CAAC;QACvB,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;YAEpB,6GAA6G;YAC7G,4DAA4D;YAC5D,IAAI,IAAI,GAA4B,CAAC,KAAa,EAAE,KAAW;gBAC7D,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACV,MAAM,KAAK,CAAC;gBACd,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,WAAW,CAAC,CAAC,CAAC;oBAC1C,MAAM,GAAG,KAAK,CAAC;gBACjB,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;gBACpD,CAAC;YACH,CAAC,CAAC;YACF,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,gBAAgB,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QACzE,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;QACpD,CAAC;QAED,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;YACnB,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM;gBACjC,IAAI,IAAI,GAA4B,CAAC,KAAa,EAAE,KAAW;oBAC7D,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;wBACV,MAAM,CAAC,KAAK,CAAC,CAAC;oBAChB,CAAC;oBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,WAAW,CAAC,CAAC,CAAC;wBAC1C,OAAO,CAAC,KAAK,CAAC,CAAC;oBACjB,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,OAAO,CAAC,MAAM,CAAC,CAAC;oBAClB,CAAC;gBACH,CAAC,CAAC;gBACF,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,gBAAgB,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;YAChF,CAAC,CAAC,CAAC;QACL,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,MAAM,CAAC;QAChB,CAAC;IAEH,CAAC,CAAC;IAEF,MAAM,CAAC;QACL,EAAE;QACF,iBAAiB;KAClB,CAAC;AACJ,CAAC;AAlGD,0CAkGC;AAED,0BAAiC,MAAgB,EAAE,QAAwB,EAAE,UAAmB,KAAK,EAAE,iBAA0B,KAAK;IACpI,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QAAC,MAAM,CAAC,IAAI,CAAC;IAAC,CAAC;IAE/B,IAAI,MAAM,GAAG,OAAO,CAAC,WAAW,CAAC,aAAa,EAAE,MAAM,CAAC,SAAS,EAAE,QAAQ,CAAC,IAAI,CAAa,CAAC;IAC7F,IAAI,SAAmB,EAAE,WAAqB,EAAE,IAA8B,CAAC;IAE/E,MAAM,QAAQ,GAAG,4BAAY,CAAC,QAAQ,IAAI,IAAI,GAAG,4BAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,IAAK,MAAc,CAAC;IAEzG,EAAE,CAAC,CAAC,OAAO,IAAI,MAAM,KAAK,QAAQ,CAAC,CAAC,CAAC;QACnC,kBAAkB;QAClB,MAAM,IAAI,wCAAkB,CAAC,kFAAkF,EAC7G,4CAAsB,CAAC,8BAA8B,CAAC,CAAC;IAC3D,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,KAAK,QAAQ,CAAC,CAAC,CAAC;QAC/B,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;YACnB,uEAAuE;YACvE,MAAM,GAAG,OAAO,CAAC,WAAW,CAAC,mBAAmB,EAAE,MAAM,CAAC,SAAS,EAAE,QAAQ,CAAC,IAAI,CAAa,CAAC;QACjG,CAAC;QAED,MAAM,cAAc,GAAG,eAAe,CAAC,MAAM,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAEnE,SAAS,GAAG,cAAc,CAAC,EAAE,CAAC;QAC9B,IAAI,GAAG,cAAc,CAAC,iBAAiB,CAAC;IAC1C,CAAC;IAED,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;QAEnB,EAAE,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC;YAC9E,MAAM,IAAI,KAAK,CAAC,iCAAiC,QAAQ,CAAC,IAAI,GAAG,CAAC,CAAC;QAErE,WAAW,GAAG,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC;IAClD,CAAC;IAED,MAAM,SAAS,GAAG,WAAW,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;IAEzD,IAAI,GAAG,0CAAkB,CAAC,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAEzD,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;QAAC,MAAM,CAAC,IAAI,CAAC;IAE5B,MAAM,CAAC;QACL,IAAI,EAAE,SAAS;QACf,WAAW,EAAE,QAAQ,CAAC,WAAW;QACjC,IAAI,EAAE,IAAI;QACV,OAAO,EAAE,SAAS;QAClB,SAAS,EAAE,WAAW;KACvB,CAAC;AACJ,CAAC;AA7CD,4CA6CC","sourcesContent":["import * as graphql from 'graphql';\n\nimport {\n  ArgumentMetadata,\n  FieldMetadata,\n  OrderByMetadata,\n} from '../metadata';\nimport { SchemaFactoryError, SchemaFactoryErrorType } from './schema.type-factory';\n\nimport { IoCContainer } from '../ioc-container';\nimport { OrderByTypeFactory } from './order-by.type-factory';\nimport { PaginationType } from '../pagination.type';\nimport { enumTypeFactory } from './enum.type-factory';\nimport { getMetadataArgsStorage } from '../metadata-builder';\nimport { interfaceTypeFactory } from './interface.type-factory';\nimport { objectTypeFactory } from './object.type-factory';\nimport { unionTypeFactory } from './union.type-factory';\n\nexport interface ResolverHolder {\n    fn: Function;\n  argumentConfigMap: { [name: string]: any; };\n}\n\nlet fieldTypeCache: { [key: string]: any } = {};\n\nexport function clearFieldTypeCache() {\n  // remove all keys without losing reference\n  Object.keys(fieldTypeCache)\n    .forEach(key => delete fieldTypeCache[key]);\n}\n\nfunction convertType(typeFn: Function, metadata: FieldMetadata | ArgumentMetadata, isInput: boolean) {\n  let returnType: any;\n\n  if (!metadata.type) {\n    if (typeFn === Number) {\n      returnType = graphql.GraphQLInt;     // FIXME or float?\n    } else if (typeFn === String) {\n      returnType = graphql.GraphQLString;\n    } else if (typeFn === Boolean) {\n      returnType = graphql.GraphQLBoolean;\n    } else if (typeFn && typeFn.prototype && getMetadataArgsStorage().filterObjectTypeByClass(typeFn).length > 0) {\n      // recursively call objectFactory\n      returnType = objectTypeFactory(typeFn, isInput);\n    }\n  } else {\n    returnType = metadata.type;\n\n    if (returnType && returnType.prototype && getMetadataArgsStorage().filterUnionTypeByClass(returnType).length > 0) {\n      returnType = unionTypeFactory(returnType, isInput);\n    } else if (returnType && returnType.prototype && getMetadataArgsStorage().filterObjectTypeByClass(returnType).length > 0) {\n      // recursively call objectFactory\n      returnType = objectTypeFactory(returnType, isInput);\n    } else if (returnType && returnType.prototype && getMetadataArgsStorage().filterInterfaceTypeByClass(returnType).length > 0) {\n      returnType = interfaceTypeFactory(returnType);\n    } else if (returnType && returnType.prototype && getMetadataArgsStorage().filterEnumsByClass(returnType).length > 0) {\n      returnType = enumTypeFactory(returnType);\n    }\n  }\n\n  if (!returnType) return null;\n\n  // Avoid duplicated type names in schema\n  //  An example of the error ocurring is using the same enum in several input or object fields\n  //  Similar issue description at https://github.com/graphql/graphql-js/issues/146\n  if (returnType.name && !fieldTypeCache[returnType.name]) {\n    fieldTypeCache[returnType.name] = returnType;\n  }\n  returnType = fieldTypeCache[returnType.name] || returnType;\n\n  if (metadata.isList) {\n    returnType = new graphql.GraphQLList(returnType);\n  }\n  if (metadata.isNonNull) {\n    returnType = new graphql.GraphQLNonNull(returnType);\n  }\n  if ((metadata as any).isPagination) { //TODO: organize functions/metadata better to avoid the need of this kind of hack\n    returnType = PaginationType.build(metadata.name, returnType);\n  }\n\n  return returnType;\n\n}\n\nexport function resolverFactory(\n  target: Function,\n  metadata: FieldMetadata,\n  fieldParentClass?: any,\n): ResolverHolder {\n  const fieldArguments = Reflect.getMetadata('design:paramtypes', target.prototype, metadata.name) as Function[];\n  const argumentConfigMap: { [name: string]: any; } = {};\n  const indexMap: { [name: string]: number; } = {};\n\n  if (metadata.context) {\n    indexMap['context'] = metadata.context.index;\n  }\n  if (metadata.root) {\n    indexMap['root'] = metadata.root.index;\n  }\n\n  if ((metadata.arguments && metadata.arguments.length > 0) || metadata.orderBy) {\n    fieldArguments.forEach((paramFn, index) => {\n      const argumentMetadata = (metadata.arguments.concat(metadata.orderBy))\n        .filter(value => value)\n        .find((value: ArgumentMetadata | OrderByMetadata) => value.index === index); //TODO: Can avoin O(n x m) here using a hash for arguments\n      if (argumentMetadata) {\n        argumentConfigMap[argumentMetadata.name] = {\n          name: argumentMetadata.name,\n          type: convertType(paramFn, argumentMetadata, true),\n        };\n        indexMap[argumentMetadata.name] = index;\n      }\n    });\n  }\n\n  const originalFn = (fieldParentClass ? fieldParentClass[metadata.name] as Function : null);\n  const fn = !fieldParentClass ? null : function (root: any, args: { [name: string]: any; }, context: any, info: any) {\n    const rest: any[] = [];\n    // TODO inject info to rest arguments\n    Object.keys(args || []).forEach(key => {\n      const index = indexMap[key];\n      if (index >= 0) {\n        rest[index] = args[key];\n      }\n    });\n\n    if (metadata.context) {\n      const index = indexMap['context'];\n      if (index >= 0) {\n        rest[index] = context;\n      }\n    }\n\n    if (metadata.root) {\n      const index = indexMap['root'];\n      if (index >= 0) {\n        rest[index] = root;\n      }\n    }\n\n    let result: any = null;\n    if (metadata.before) {\n\n      // TODO: This whole chain should be promise based but this would impact the whole `schemaFactory` call chain.\n      //  So Promise will be added as a future feature/enhancement\n      let next: (error?: Error) => void = (error?: Error, value?: any): any => {\n        if (error) {\n          throw error;\n        } else if (typeof (value) !== 'undefined') {\n          result = value;\n        } else {\n          result = originalFn.apply(fieldParentClass, rest);\n        }\n      };\n      metadata.before.middleware.call(fieldParentClass, context, args, next);\n    } else {\n      result = originalFn.apply(fieldParentClass, rest);\n    }\n\n    if (metadata.after) {\n      return new Promise((resolve, reject) => {\n        let next: (error?: Error) => void = (error?: Error, value?: any): any => {\n          if (error) {\n            reject(error);\n          } else if (typeof (value) !== 'undefined') {\n            resolve(value);\n          } else {\n            resolve(result);\n          }\n        };\n        metadata.after.middleware.call(fieldParentClass, context, args, result, next);\n      });\n    } else {\n      return result;\n    }\n\n  };\n\n  return {\n    fn,\n    argumentConfigMap,\n  };\n}\n\nexport function fieldTypeFactory(target: Function, metadata?: FieldMetadata, isInput: boolean = false, isSubscription: boolean = false) {\n  if (!metadata) { return null; }\n\n  let typeFn = Reflect.getMetadata('design:type', target.prototype, metadata.name) as Function;\n  let resolveFn: Function, subscribeFn: Function, args: { [name: string]: any; };\n\n  const instance = IoCContainer.INSTANCE != null ? IoCContainer.INSTANCE.get(target) : new (target as any);\n\n  if (isInput && typeFn === Function) {\n    // TODO write test\n    throw new SchemaFactoryError('Field declared in a class annotated by @InputObjectType should not be a function',\n      SchemaFactoryErrorType.INPUT_FIELD_SHOULD_NOT_BE_FUNC);\n  } else if (typeFn === Function) {\n    if (!metadata.type) {\n      // infer type from function return type if no explicit type is provided\n      typeFn = Reflect.getMetadata('design:returntype', target.prototype, metadata.name) as Function;\n    }\n\n    const resolverHolder = resolverFactory(target, metadata, instance);\n\n    resolveFn = resolverHolder.fn;\n    args = resolverHolder.argumentConfigMap;\n  }\n\n  if (isSubscription) {\n\n    if (!instance || !instance[metadata.name] || !instance[metadata.name].subscribe)\n      throw new Error(`invalid subscription object: '${metadata.name}'`);\n\n    subscribeFn = instance[metadata.name].subscribe;\n  }\n\n  const fieldType = convertType(typeFn, metadata, isInput);\n\n  args = OrderByTypeFactory.orderByFactory(metadata, args);\n\n  if (!fieldType) return null;\n\n  return {\n    type: fieldType,\n    description: metadata.description,\n    args: args,\n    resolve: resolveFn,\n    subscribe: subscribeFn,\n  };\n}\n"]}