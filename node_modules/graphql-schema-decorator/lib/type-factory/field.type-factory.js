"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql = require("graphql");
const schema_type_factory_1 = require("./schema.type-factory");
const ioc_container_1 = require("../ioc-container");
const order_by_type_factory_1 = require("./order-by.type-factory");
const pagination_type_1 = require("../pagination.type");
const enum_type_factory_1 = require("./enum.type-factory");
const metadata_builder_1 = require("../metadata-builder");
const interface_type_factory_1 = require("./interface.type-factory");
const object_type_factory_1 = require("./object.type-factory");
const union_type_factory_1 = require("./union.type-factory");
let fieldTypeCache = {};
function clearFieldTypeCache() {
    // remove all keys without losing reference
    Object.keys(fieldTypeCache)
        .forEach(key => delete fieldTypeCache[key]);
}
exports.clearFieldTypeCache = clearFieldTypeCache;
function convertType(typeFn, metadata, isInput) {
    let returnType;
    if (!metadata.type) {
        if (typeFn === Number) {
            returnType = graphql.GraphQLInt; // FIXME or float?
        }
        else if (typeFn === String) {
            returnType = graphql.GraphQLString;
        }
        else if (typeFn === Boolean) {
            returnType = graphql.GraphQLBoolean;
        }
        else if (typeFn && typeFn.prototype && metadata_builder_1.getMetadataArgsStorage().filterObjectTypeByClass(typeFn).length > 0) {
            // recursively call objectFactory
            returnType = object_type_factory_1.objectTypeFactory(typeFn, isInput);
        }
    }
    else {
        returnType = metadata.type;
        if (returnType && returnType.prototype && metadata_builder_1.getMetadataArgsStorage().filterUnionTypeByClass(returnType).length > 0) {
            returnType = union_type_factory_1.unionTypeFactory(returnType, isInput);
        }
        else if (returnType && returnType.prototype && metadata_builder_1.getMetadataArgsStorage().filterObjectTypeByClass(returnType).length > 0) {
            // recursively call objectFactory
            returnType = object_type_factory_1.objectTypeFactory(returnType, isInput);
        }
        else if (returnType && returnType.prototype && metadata_builder_1.getMetadataArgsStorage().filterInterfaceTypeByClass(returnType).length > 0) {
            returnType = interface_type_factory_1.interfaceTypeFactory(returnType);
        }
        else if (returnType && returnType.prototype && metadata_builder_1.getMetadataArgsStorage().filterEnumsByClass(returnType).length > 0) {
            returnType = enum_type_factory_1.enumTypeFactory(returnType);
        }
    }
    if (!returnType)
        return null;
    // Avoid duplicated type names in schema
    //  An example of the error ocurring is using the same enum in several input or object fields
    //  Similar issue description at https://github.com/graphql/graphql-js/issues/146
    if (returnType.name && !fieldTypeCache[returnType.name]) {
        fieldTypeCache[returnType.name] = returnType;
    }
    returnType = fieldTypeCache[returnType.name] || returnType;
    if (metadata.isList) {
        returnType = new graphql.GraphQLList(returnType);
    }
    if (metadata.isNonNull) {
        returnType = new graphql.GraphQLNonNull(returnType);
    }
    if (metadata.isPagination) {
        returnType = pagination_type_1.PaginationType.build(metadata.name, returnType);
    }
    return returnType;
}
function resolverFactory(target, metadata, fieldParentClass) {
    const fieldArguments = Reflect.getMetadata('design:paramtypes', target.prototype, metadata.name);
    const argumentConfigMap = {};
    const indexMap = {};
    if (metadata.context) {
        indexMap['context'] = metadata.context.index;
    }
    if (metadata.root) {
        indexMap['root'] = metadata.root.index;
    }
    if ((metadata.arguments && metadata.arguments.length > 0) || metadata.orderBy) {
        fieldArguments.forEach((paramFn, index) => {
            const argumentMetadata = (metadata.arguments.concat(metadata.orderBy))
                .filter(value => value)
                .find((value) => value.index === index); //TODO: Can avoin O(n x m) here using a hash for arguments
            if (argumentMetadata) {
                argumentConfigMap[argumentMetadata.name] = {
                    name: argumentMetadata.name,
                    type: convertType(paramFn, argumentMetadata, true),
                };
                indexMap[argumentMetadata.name] = index;
            }
        });
    }
    const originalFn = (fieldParentClass ? fieldParentClass[metadata.name] : null);
    const fn = !fieldParentClass ? null : function (root, args, context, info) {
        const rest = [];
        // TODO inject info to rest arguments
        Object.keys(args || []).forEach(key => {
            const index = indexMap[key];
            if (index >= 0) {
                rest[index] = args[key];
            }
        });
        if (metadata.context) {
            const index = indexMap['context'];
            if (index >= 0) {
                rest[index] = context;
            }
        }
        if (metadata.root) {
            const index = indexMap['root'];
            if (index >= 0) {
                rest[index] = root;
            }
        }
        let result = null;
        if (metadata.before) {
            // TODO: This whole chain should be promise based but this would impact the whole `schemaFactory` call chain.
            //  So Promise will be added as a future feature/enhancement
            let next = (error, value) => {
                if (error) {
                    throw error;
                }
                else if (typeof (value) !== 'undefined') {
                    result = value;
                }
                else {
                    result = originalFn.apply(fieldParentClass, rest);
                }
            };
            metadata.before.middleware.call(fieldParentClass, context, args, next);
        }
        else {
            result = originalFn.apply(fieldParentClass, rest);
        }
        if (metadata.after) {
            return new Promise((resolve, reject) => {
                let next = (error, value) => {
                    if (error) {
                        reject(error);
                    }
                    else if (typeof (value) !== 'undefined') {
                        resolve(value);
                    }
                    else {
                        resolve(result);
                    }
                };
                metadata.after.middleware.call(fieldParentClass, context, args, result, next);
            });
        }
        else {
            return result;
        }
    };
    return {
        fn,
        argumentConfigMap,
    };
}
exports.resolverFactory = resolverFactory;
function fieldTypeFactory(target, metadata, isInput = false, isSubscription = false) {
    if (!metadata) {
        return null;
    }
    let typeFn = Reflect.getMetadata('design:type', target.prototype, metadata.name);
    let resolveFn, subscribeFn, args;
    const instance = ioc_container_1.IoCContainer.INSTANCE != null ? ioc_container_1.IoCContainer.INSTANCE.get(target) : new target;
    if (isInput && typeFn === Function) {
        // TODO write test
        throw new schema_type_factory_1.SchemaFactoryError('Field declared in a class annotated by @InputObjectType should not be a function', schema_type_factory_1.SchemaFactoryErrorType.INPUT_FIELD_SHOULD_NOT_BE_FUNC);
    }
    else if (typeFn === Function) {
        if (!metadata.type) {
            // infer type from function return type if no explicit type is provided
            typeFn = Reflect.getMetadata('design:returntype', target.prototype, metadata.name);
        }
        const resolverHolder = resolverFactory(target, metadata, instance);
        resolveFn = resolverHolder.fn;
        args = resolverHolder.argumentConfigMap;
    }
    if (isSubscription) {
        if (!instance || !instance[metadata.name] || !instance[metadata.name].subscribe)
            throw new Error(`invalid subscription object: '${metadata.name}'`);
        subscribeFn = instance[metadata.name].subscribe;
    }
    const fieldType = convertType(typeFn, metadata, isInput);
    args = order_by_type_factory_1.OrderByTypeFactory.orderByFactory(metadata, args);
    if (!fieldType)
        return null;
    return {
        type: fieldType,
        description: metadata.description,
        args: args,
        resolve: resolveFn,
        subscribe: subscribeFn,
    };
}
exports.fieldTypeFactory = fieldTypeFactory;
//# sourceMappingURL=field.type-factory.js.map