"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql = require("graphql");
const metadata_1 = require("../metadata");
const object_type_factory_1 = require("./object.type-factory");
const field_type_factory_1 = require("./field.type-factory");
const object_type_factory_2 = require("./object.type-factory");
const metadata_builder_1 = require("../metadata-builder");
var SchemaFactoryErrorType;
(function (SchemaFactoryErrorType) {
    SchemaFactoryErrorType[SchemaFactoryErrorType["NO_SCHEMA_ANNOTATION"] = 0] = "NO_SCHEMA_ANNOTATION";
    SchemaFactoryErrorType[SchemaFactoryErrorType["NO_QUERY_FIELD"] = 1] = "NO_QUERY_FIELD";
    SchemaFactoryErrorType[SchemaFactoryErrorType["NO_FIELD"] = 2] = "NO_FIELD";
    SchemaFactoryErrorType[SchemaFactoryErrorType["NO_VALUE"] = 3] = "NO_VALUE";
    SchemaFactoryErrorType[SchemaFactoryErrorType["NO_TYPE_ORDERBY_PARENT_FIELD"] = 4] = "NO_TYPE_ORDERBY_PARENT_FIELD";
    SchemaFactoryErrorType[SchemaFactoryErrorType["INVALID_OBJECT_TYPE_METADATA"] = 5] = "INVALID_OBJECT_TYPE_METADATA";
    SchemaFactoryErrorType[SchemaFactoryErrorType["INPUT_FIELD_SHOULD_NOT_BE_FUNC"] = 6] = "INPUT_FIELD_SHOULD_NOT_BE_FUNC";
    SchemaFactoryErrorType[SchemaFactoryErrorType["INPUT_FIELD_SHOULD_NOT_BE_PAGINATED"] = 7] = "INPUT_FIELD_SHOULD_NOT_BE_PAGINATED";
    SchemaFactoryErrorType[SchemaFactoryErrorType["VALUE_SHOULD_NOT_BE_FUNC"] = 8] = "VALUE_SHOULD_NOT_BE_FUNC";
    SchemaFactoryErrorType[SchemaFactoryErrorType["ORDER_BY_OUTSIDE_PAGINATION"] = 9] = "ORDER_BY_OUTSIDE_PAGINATION";
    SchemaFactoryErrorType[SchemaFactoryErrorType["INPUT_FIELD_SHOULD_NOT_HAVE_INTERFACE"] = 10] = "INPUT_FIELD_SHOULD_NOT_HAVE_INTERFACE";
})(SchemaFactoryErrorType = exports.SchemaFactoryErrorType || (exports.SchemaFactoryErrorType = {}));
class SchemaFactoryError extends Error {
    constructor(msg, type) {
        super(msg);
        this.type = type;
        this.message = msg;
    }
}
exports.SchemaFactoryError = SchemaFactoryError;
function getEntryObject(target, type, mandatory, entryObjectTypeFactory) {
    const metadatas = metadata_builder_1.getMetadataBuilder().buildEntryTypeMetadata(target, type);
    if (mandatory && (!metadatas || metadatas.length === 0)) {
        throw new SchemaFactoryError(`Target should have @${type} field`, SchemaFactoryErrorType.NO_QUERY_FIELD);
    }
    let fieldMap = metadatas.map(metadata => {
        const fieldTarget = Reflect.getMetadata('design:type', metadata.target, metadata.property);
        const fieldMetadatas = metadata_builder_1.getMetadataBuilder().buildFieldMetadata(fieldTarget.prototype);
        return fieldMetadatas.reduce((fields, fieldMetadata) => {
            fields[fieldMetadata.name] = field_type_factory_1.fieldTypeFactory(fieldTarget, fieldMetadata, undefined, metadata.isSubscription);
            return fields;
        }, {});
    })
        .reduce((map, fields) => (Object.assign({}, map, fields)), {});
    return Object.keys(fieldMap).length > 0 ? entryObjectTypeFactory(fieldMap) : undefined;
}
function getAllTypes() {
    return metadata_builder_1.getMetadataArgsStorage()
        .objects
        .filter(arg => arg.interfaces.length > 0)
        .map(arg => object_type_factory_2.objectTypeFactory(arg.target, arg.isInput));
}
function schemaFactory(target) {
    if (metadata_builder_1.getMetadataBuilder().buildSchemaMetadata(target).length !== 1) {
        throw new SchemaFactoryError('One and only one argument of schemaFactory should be annotated with @Schema() decorator', SchemaFactoryErrorType.NO_SCHEMA_ANNOTATION);
    }
    const query = getEntryObject(target, metadata_1.EntryType.Query, true, object_type_factory_1.queryObjectTypeFactory);
    const mutation = getEntryObject(target, metadata_1.EntryType.Mutation, false, object_type_factory_1.mutationObjectTypeFactory);
    const subscription = getEntryObject(target, metadata_1.EntryType.Subscription, false, object_type_factory_1.subscriptionObjectTypeFactory);
    const types = getAllTypes();
    return new graphql.GraphQLSchema({
        query: query,
        mutation: mutation,
        subscription: subscription,
        types: types,
    });
}
exports.schemaFactory = schemaFactory;
//# sourceMappingURL=schema.type-factory.js.map