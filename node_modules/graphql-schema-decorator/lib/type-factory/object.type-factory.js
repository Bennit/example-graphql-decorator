"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql = require("graphql");
const schema_type_factory_1 = require("./schema.type-factory");
const type_factory_1 = require("../type-factory");
const interface_type_factory_1 = require("./interface.type-factory");
const metadata_builder_1 = require("../metadata-builder");
const array_utils_1 = require("../array.utils");
let objectTypeRepository = {};
function clearObjectTypeRepository() {
    objectTypeRepository = {};
}
exports.clearObjectTypeRepository = clearObjectTypeRepository;
function objectTypeFactory(target, isInput = false) {
    return metadata_builder_1.getMetadataBuilder()
        .buildObjectTypeMetadata(target)
        .map(metadata => {
        const cached = objectTypeRepository[metadata.name];
        if (cached) {
            return cached;
        }
        if (metadata.isInput !== isInput) {
            // TODO write test
            throw new schema_type_factory_1.SchemaFactoryError('', schema_type_factory_1.SchemaFactoryErrorType.INVALID_OBJECT_TYPE_METADATA);
        }
        const fieldMetadataList = metadata_builder_1.getMetadataBuilder()
            .buildFieldMetadata(target.prototype)
            .map(field => ({ target, field }))
            .concat(array_utils_1.flatten(metadata.interfaces.map(interfaceMetadata => array_utils_1.flatten(metadata_builder_1.getMetadataBuilder().buildFieldMetadata(interfaceMetadata.target.prototype).map(field => ({
            target: interfaceMetadata.target,
            field: field,
        }))))));
        if (fieldMetadataList.length === 0) {
            throw new schema_type_factory_1.SchemaFactoryError('Class annotated by @ObjectType() should has one or more fields annotated by @Field()', schema_type_factory_1.SchemaFactoryErrorType.NO_FIELD);
        }
        const fields = fieldMetadataList.reduce((map, fieldMetadata) => {
            let field = type_factory_1.fieldTypeFactory(fieldMetadata.target, fieldMetadata.field, isInput);
            if (!field) {
                throw new schema_type_factory_1.SchemaFactoryError(`@ObjectType()'s ${fieldMetadata.field.name} is annotated by @Field() but no type could be inferred`, schema_type_factory_1.SchemaFactoryErrorType.NO_FIELD);
            }
            map[fieldMetadata.field.name] = field;
            return map;
        }, {});
        const interfaces = metadata.interfaces.map(interfaceMetadata => interface_type_factory_1.interfaceTypeFactory(interfaceMetadata.target));
        const params = {
            name: metadata.name,
            fields,
            description: metadata.description,
            interfaces: interfaces,
        };
        objectTypeRepository[metadata.name] = isInput ? new graphql.GraphQLInputObjectType(params) : new graphql.GraphQLObjectType(params);
        return objectTypeRepository[metadata.name];
    })
        .find((value, index) => index === 0);
}
exports.objectTypeFactory = objectTypeFactory;
function mutationObjectTypeFactory(fieldsDict) {
    let mutationRootObject = new graphql.GraphQLObjectType({
        name: 'Mutations',
        description: 'Perform actions over the backend',
        fields: fieldsDict,
    });
    return mutationRootObject;
}
exports.mutationObjectTypeFactory = mutationObjectTypeFactory;
function queryObjectTypeFactory(fieldsDict) {
    return new graphql.GraphQLObjectType({
        name: 'Queries',
        description: 'Reads from the backend',
        fields: fieldsDict,
    });
}
exports.queryObjectTypeFactory = queryObjectTypeFactory;
function subscriptionObjectTypeFactory(fieldsDict) {
    return new graphql.GraphQLObjectType({
        name: 'Subscriptions',
        description: 'Realtime stream from the backend',
        fields: fieldsDict,
    });
}
exports.subscriptionObjectTypeFactory = subscriptionObjectTypeFactory;
//# sourceMappingURL=object.type-factory.js.map